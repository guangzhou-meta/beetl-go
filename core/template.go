package core

import (
	"strings"
)

import (
	"github.com/guangzhou-meta/beetl-go/common"
	"github.com/guangzhou-meta/beetl-go/core/cache"
	eio "github.com/guangzhou-meta/beetl-go/core/io"
)

type Template struct {
	program  *Program
	cf       *Configuration
	gt       *GroupTemplate
	isRoot   bool
	AjaxId   *string
	ctx      *Context
	Resource ResourceI
	rangeSql *OffsetLimitRange
}

func NewTemplate(gt *GroupTemplate, program *Program, resource ResourceI, cf *Configuration, buffer *cache.ContextBuffer) *Template {
	ctx := NewContext(gt, buffer)
	inst := &Template{
		program: program,
		cf:      cf,
		gt:      gt,
		ctx:     ctx,
	}
	if cf.SafeOutput {
		ctx.safeOutput = true
	}
	if buffer == nil {
		inst.Resource = resource
	}
	return inst
}

func (t *Template) Binding(params map[string]interface{}) {
	if params == nil || len(params) == 0 {
		return
	}
	for k, v := range params {
		t.ctx.Set(k, v)
	}
}

func (t *Template) SetPageMode(page int, size int, start int) {
	t.ctx.GlobalVar[common.DBAutoGeneratedSqlPAGE] = true
	t.rangeSql = NewOffsetLimitRange(NewAbstractDBStyle(t.cf))
	t.ctx.GlobalVar[common.DBAutoGeneratedSqlPageOrigin] = page
	t.rangeSql.AddTemplateRangeParas(t.ctx.GlobalVar, start, size)
}

func (t *Template) Render() []common.SqlResultI {
	var result []common.SqlResultI
	hasPageQuery := t.ctx.GlobalVar[common.DBAutoGeneratedSqlPAGE]
	isPageQuery := hasPageQuery != nil && hasPageQuery.(bool)
	r := t.getResult()
	delete(t.ctx.GlobalVar, common.DBAutoGeneratedSqlPAGE)
	if isPageQuery { // 追加limit
		result = append(result, common.NewSqlCountResult(r))
		r = t.getResult()
		r = t.rangeSql.ToTemplateRange(nil, r)
		resL := NewStringTemplateResourceLoader()
		resource := resL.GetResource(r)
		t.program = t.gt.LoadTemplate(resource)
		r = t.getResult()
		paras := t.ctx.GlobalVar
		page := paras[common.DBAutoGeneratedSqlPageOrigin].(int)
		size := paras[common.DBAutoGeneratedSqlPageSize].(int)
		offset := paras[common.DBAutoGeneratedSqlOFFSET].(int)
		result = append(result, common.NewSqlPageResult(r).SetPage(page).SetSize(size).SetOffset(offset))
	} else {
		result = append(result, common.NewSqlListResult(r))
	}
	return result
}

func (t *Template) getResult() string {
	sw := eio.NewNoLockByteArrayWriter()
	t.renderTo(sw)
	r := sw.String()
	//r = strings.ReplaceAll(strings.TrimSpace(r), "\r\n", " ")
	//r = strings.ReplaceAll(strings.TrimSpace(r), "\n", " ")
	return strings.TrimSpace(r)
}

func (t *Template) renderTo(writer *eio.NoLockByteArrayWriter) {
	t.renderToByte(NewByteWriterByte(writer, t.cf.charset, t.ctx, nil))
}

func (t *Template) renderToByte(writerByte *ByteWriterByte) {
	ctx := t.ctx
	ctx.byteWriter = writerByte
	ctx.byteOutputMode = t.cf.directByteOutput
	ctx.gt = t.gt
	ctx.Template = t
	defer func(ctx *Context) {
		if t.isRoot {
			ctx.Destroy()
		}
	}(ctx)
	if t.gt.sharedVars != nil {
		for k, v := range t.gt.sharedVars {
			ctx.Set(k, v)
		}
	}
	if t.AjaxId != nil {
		// TODO
	} else {
		t.program.MetaData.InitContext(ctx)
		t.program.Execute(ctx)
	}
	if t.isRoot {
		writerByte.Flush()
	}
}
